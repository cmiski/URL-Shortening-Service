initialize project
  npm init -y

do "dev" : "node --watch " for nodemon watching

install dependencies
  npm install express dotenv zod pino
  npm install ioredis kafkajs mongoose

docker-compose.yml is a config file for docker compose to define and run multi container docker applications (kinda like a blueprint that tells docker how to build and run the application)
  every container(service) can talk to each other uisng service name

  "docker compose up -d" --> starts all containers
  "docker compose ps" --> displays all running containers
  "docker composr logs" --> displays all logs
  "docker compose down": stops all containers, but leaves volumes intact
  "docker compose down -v": stops all containers and removes all volumes

  "docker exec -it <container name> redis-cli" --> to access redis cli
  "docker exec -it <container name> redis-cli ping" --> to check if redis is running
  "docker exec -it <container name> rpk cluster info" --> to check if redpanda is running

  my yml file is a optimezed setup for backend systems, event-driven architecture, Caching + DB + Streaming, microservices etc
    refer docker-compose.yml for details

  PHASE 1: CORE REDIRECT ENGINE (performance critical)
    --> this defines the latency discipline for the entire project

    --? Note : "The redirect path must be boring, fast, and dumb."

      ^^ created basic foundational express server [src/app.js, src/server.js]
      ^^ created health check endpoint [src/routes/health.js]
      ^^ configured DB connection [src/config/db.js]
      ^^ configured Redis connection [src/config/redis.js]
      ^^ created URL model [src/models/url.model.js]

    "index : true" in the DB URL schema means that the field will be indexed for faster lookup O(log n) instead of O(n) --> Mongo creates a B-tree index internally 


  CACHE-ASIDE STRATEGY/PATTERN : 
      1) cache hit : read data from cache if available
      2) cache miss : read data from DB
      3) wtite data to cache

    Note: for read only paths always use lean()

      ^^ created redirect service : resolveShortCode -> finds the long url and returns it to the redirect controller [src/services/redirect.service.js]
      ^^ created redirect controller : redirectHandler -> if long Url found redirect to that url and send 302 [src/controllers/redirect.controller.js]
      ^^ created redirect route : /:shortcut [src/routes/redirect.js]


    Note: never run plain mongosh for docker db, use "docker exec -it urlshorteningservice-mongo-1 mongosh"


    My redirect is working now (it redirects to gws i.e goole web server) so it hides the 302 and just show 200 on the redirected url

      current flow : 
        Client
           ──▶ My server (302 Redirect)
                 ──▶ https://google.com
                       ──▶ Google responds with 200 OK + HTML


        So rn, i have a high-performance redirect path with redis-first cache-aside strategy.

